import fs from 'fs/promises';
import path from 'path';

/**
 * Generate markdown files for documentation
 * This is a fallback when Craft MCP is not available
 */
class OutputGenerator {
  constructor(outputDir = 'generated-docs') {
    this.outputDir = outputDir;
  }

  /**
   * Initialize output directory
   */
  async initialize() {
    try {
      await fs.mkdir(this.outputDir, { recursive: true });
      console.log(`ðŸ“ Output directory created: ${this.outputDir}`);
    } catch (error) {
      console.error('Error creating output directory:', error);
    }
  }

  /**
   * Save documentation to files
   */
  async saveDocumentation(repoName, documents) {
    await this.initialize();

    const sanitizedName = repoName.replace(/\//g, '-');
    const repoDir = path.join(this.outputDir, sanitizedName);

    await fs.mkdir(repoDir, { recursive: true });

    console.log(`\nðŸ“ Generating documentation files for ${repoName}...`);

    for (const [key, doc] of Object.entries(documents)) {
      if (doc && doc.title) {
        const filename = `${doc.title.replace(/[^a-z0-9]/gi, '-')}.md`;
        const filepath = path.join(repoDir, filename);

        // Get content - it might be stored in different ways
        let content = '';
        if (typeof doc.content === 'string') {
          content = doc.content;
        } else if (doc.contents && Array.isArray(doc.contents)) {
          content = doc.contents.map(c => c.text || '').join('\n');
        }

        await fs.writeFile(filepath, content, 'utf-8');
        console.log(`  âœ… ${filename}`);
      }
    }

    // Create an index file
    await this.createIndexFile(repoDir, repoName, documents);

    console.log(`\nðŸŽ‰ Documentation generated at: ${repoDir}`);
    console.log(`ðŸ“‚ You can now import these files into Craft manually\n`);

    return repoDir;
  }

  /**
   * Create an index/README file
   */
  async createIndexFile(repoDir, repoName, documents) {
    const indexContent = `# ${repoName} - Engineering Brain

*Generated by GitCraft on ${new Date().toISOString()}*

## ðŸ“š Documentation Files

${Object.entries(documents).map(([key, doc]) => `- ${doc.title || key}`).join('\n')}

## ðŸš€ How to Import to Craft

1. Open Craft application
2. Create a new folder called "Engineering Brain"
3. For each markdown file in this directory:
   - Copy the content
   - Create a new document in Craft
   - Paste the content
   - Give it the same title

## ðŸ”„ Automatic Updates

To enable automatic updates:
1. Set up the Craft MCP connection properly
2. Uncomment the MCP implementation in backend/src/integrations/craft.js
3. Restart the backend server

---

**GitCraft** - Living Engineering Documentation
`;

    await fs.writeFile(path.join(repoDir, 'README.md'), indexContent, 'utf-8');
    console.log(`  âœ… README.md (import guide)`);
  }

  /**
   * Get the initial content that would be created
   */
  getInitialContent(repoName) {
    return {
      techSpec: this.getTechSpecContent(repoName),
      releaseNotes: this.getReleaseNotesContent(),
      adrs: this.getADRContent(),
      tasks: this.getTasksContent()
    };
  }

  getTechSpecContent(repoName) {
    return `# Technical Specification: ${repoName}

## Overview
*Analysis in progress...*

This document will contain:
- Project purpose and goals
- System architecture
- Core modules and components
- Public APIs and interfaces
- Technology stack

---
*Last updated: ${new Date().toISOString()}*
*Generated by GitCraft*
`;
  }

  getReleaseNotesContent() {
    return `# Release Notes

## v0.0.0 - Initial Analysis (${new Date().toISOString().split('T')[0]})

### Initial Setup
- Repository connected to GitCraft
- Documentation structure created
- Automated analysis initiated

---
*Generated by GitCraft*
`;
  }

  getADRContent() {
    return `# Architectural Decision Records (ADRs)

## ADR-000: Initial Architecture Understanding

**Status**: Proposed (Inferred from code)

**Date**: ${new Date().toISOString().split('T')[0]}

### Context
This is the initial architectural understanding based on automated code analysis. 
This ADR documents the inferred architecture and serves as a baseline for future decisions.

### Decision
Analysis in progress...

### Consequences
To be determined after initial analysis.

---
*Generated by GitCraft*
`;
  }

  getTasksContent() {
    return `# Engineering Tasks

## Open Questions
- [ ] Review and validate generated documentation
- [ ] Add missing architectural details
- [ ] Document public APIs
- [ ] Update deployment procedures

---
*Generated by GitCraft*
`;
  }
}

export default OutputGenerator;


